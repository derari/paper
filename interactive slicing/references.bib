
@inproceedings{balzer_exdams:_1969,
	location = {New York, {NY}, {USA}},
	title = {{EXDAMS}: Extendable Debugging and Monitoring System},
	url = {http://doi.acm.org/10.1145/1476793.1476881},
	doi = {10.1145/1476793.1476881},
	series = {{AFIPS} '69 (Spring)},
	pages = {567--580},
	booktitle = {Proceedings of the May 14-16, 1969, Spring Joint Computer Conference},
	publisher = {{ACM}},
	author = {Balzer, R. M.},
	date = {1969}
}

@inproceedings{weiser_program_1981,
	location = {Piscataway, {NJ}, {USA}},
	title = {Program Slicing},
	isbn = {0-89791-146-6},
	url = {http://dl.acm.org/citation.cfm?id=800078.802557},
	series = {{ICSE} '81},
	abstract = {Program slicing is a method used by experienced computer programmers for abstracting from programs. Starting from a subset of a program's behavior, slicing reduces that program to a minimal form which still produces that behavior. The reduced program, called a “slice”, is an independent program guaranteed to faithfully represent the original program within the domain of the specified subset of behavior. Finding a slice is in general unsolvable. A dataflow algorithm is presented for approximating slices when the behavior subset is specified as the values of a set of variables at a statement. Experimental evidence is presented that these slices are used by programmers during debugging. Experience with two automatic slicing tools is summarized. New measures of program complexity are suggested based on the organization of a program's slices.},
	pages = {439--449},
	booktitle = {Proceedings of the 5th international conference on Software engineering},
	publisher = {{IEEE} Press},
	author = {Weiser, Mark},
	urldate = {2013-10-15},
	date = {1981},
	keywords = {Data flow analysis, Debugging, Human Factors, Program maintenance, Program metrics, Software tools},
	file = {Weiser 1981 - Program slicing.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\RQM5N9CU\\Weiser 1981 - Program slicing.pdf:application/pdf}
}

@article{weiser_programmers_1982,
	title = {Programmers Use Slices When Debugging},
	volume = {25},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/358557.358577},
	doi = {10.1145/358557.358577},
	abstract = {Computer programmers break apart large programs into smaller coherent pieces. Each of these pieces: functions, subroutines, modules, or abstract datatypes, is usually a contiguous piece of program text. The experiment reported here shows that programmers also routinely break programs into one kind of coherent piece which is not coniguous. When debugging unfamiliar programs programmers use program pieces called slices which are sets of statements related by their flow of data. The statements in a slice are not necessarily textually contiguous, but may be scattered through a program.},
	pages = {446--452},
	number = {7},
	journaltitle = {Commun. {ACM}},
	author = {Weiser, Mark},
	date = {1982-07},
	keywords = {program decomposition, slice},
	file = {Weiser 1982 - Programmers use slices when debugging.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\3STUGDS6\\Weiser 1982 - Programmers use slices when debugging.pdf:application/pdf}
}

@inproceedings{feldman_igor:_1988,
	location = {New York, {NY}, {USA}},
	title = {{IGOR}: a system for program debugging via reversible execution},
	isbn = {0-89791-296-9},
	url = {http://doi.acm.org/10.1145/68210.69226},
	doi = {10.1145/68210.69226},
	series = {{PADD} '88},
	shorttitle = {{IGOR}},
	abstract = {Typical debugging tools are insufficiently powerful to find the most difficult types of program misbehaviors. We have implemented a prototype of a new debugging system, {IGOR}, which provides a great deal more useful information and offers new abilities that are quite promising. The system runs fast enough to be quite useful while providing many features that are usually available only in an interpreted environment. We describe here some improved facilities (reverse execution, selective searching of execution history, substitution of data and executable parts of the programs) that are needed for serious debugging and are not found in traditional single-thread debugging tools. With a little help from the operating system, we provide these capabilities at reasonable cost without modifying the executable code and running fairly close to full speed. The prototype runs under the {DUNE} distributed operating system.
The current system only supports debugging of single-thread programs. The paper describes planned extensions to make use of extra processors to speed the system and for applying the technique to multi-thread and time dependent executions.},
	pages = {112--123},
	booktitle = {Proceedings of the 1988 {ACM} {SIGPLAN} and {SIGOPS} workshop on Parallel and distributed debugging},
	publisher = {{ACM}},
	author = {Feldman, Stuart I. and Brown, Channing B.},
	urldate = {2013-01-20},
	date = {1988},
	file = {Feldman, Brown 1988 - IGOR.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\H2C7AANJ\\Feldman, Brown 1988 - IGOR.pdf:application/pdf}
}

@inproceedings{agrawal_dynamic_1990,
	location = {New York, {NY}, {USA}},
	title = {Dynamic Program Slicing},
	isbn = {0-89791-364-7},
	url = {http://doi.acm.org/10.1145/93542.93576},
	doi = {10.1145/93542.93576},
	series = {{PLDI} '90},
	abstract = {Program slices are useful in debugging, testing, maintenance, and understanding of programs. The conventional notion of a program slice, the static slice, is the set of all statements that might affect the value of a given variable occurrence. In this paper, we investigate the concept of the dynamic slice consisting of all statements that actually affect the value of a variable occurrence for a given program input. The sensitivity of dynamic slicing to particular program inputs makes it more useful in program debugging and testing than static slicing. Several approaches for computing dynamic slices are examined. The notion of a Dynamic Dependence Graph and its use in computing dynamic slices is discussed. The Dynamic Dependence Graph may be unbounded in length; therefore, we introduce the economical concept of a Reduced Dynamic Dependence Graph, which is proportional in size to the number of dynamic slices arising during the program execution.},
	pages = {246--256},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1990 Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Agrawal, Hiralal and Horgan, Joseph R.},
	urldate = {2014-03-12},
	date = {1990},
	file = {Agrawal, Horgan 1990 - Dynamic Program Slicing.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\37QA6ESG\\Agrawal, Horgan 1990 - Dynamic Program Slicing.pdf:application/pdf}
}

@article{korel_dynamic_1990,
	title = {Dynamic slicing of computer programs},
	volume = {13},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/0164121290900943},
	doi = {10.1016/0164-1212(90)90094-3},
	pages = {187--195},
	number = {3},
	journaltitle = {Journal of Systems and Software},
	shortjournal = {Journal of Systems and Software},
	author = {Korel, Bogdan and Laski, Janusz},
	urldate = {2014-03-13},
	date = {1990-11},
	file = {ScienceDirect Snapshot:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\XHXW67QB\\0164121290900943.html:text/html}
}

@article{agrawal_debugging_1993,
	title = {Debugging with dynamic slicing and backtracking},
	volume = {23},
	rights = {Copyright © 1993 John Wiley \& Sons, Ltd},
	issn = {1097-024X},
	url = {http://onlinelibrary.wiley.com/doi/10.1002/spe.4380230603/abstract},
	doi = {10.1002/spe.4380230603},
	abstract = {Programmers spend considerable time debugging code. Symbolic debuggers provide some help but the task remains complex and difficult. Other than breakpoints and tracing, these tools provide little high-level help. Programmers must perform many tasks manually that the tools could perform automatically, such as finding which statements in the program affect the value of an output variable for a given test case, and what was the value of a given variable when the control last reached a given program location. If debugging tools provided explicit support for these tasks, the debugging process could be automated to a significant extent.In this paper we present a debugging model, based on dynamic program slicing and execution backtracking techniques, that easily lends itself to automation. This model is based on experience with using these techniques to debug software. We also present a prototype debugging tool, {SPYDER}, that explicitly supports the proposed model, and with which we are performing further debugging research.},
	pages = {589--616},
	number = {6},
	journaltitle = {Software: Practice and Experience},
	author = {Agrawal, Hiralal and Demillo, Richard A. and Spafford, Eugene H.},
	urldate = {2013-01-20},
	date = {1993},
	langid = {english},
	keywords = {Dynamic program slicing, Execution backtracking, program debugging, Program slicing, Reverse program execution},
	file = {Agrawal, Demillo, Spafford 1993 - Debugging with dynamic slicing and backtracking.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\9BT38VTM\\Agrawal, Demillo, Spafford 1993 - Debugging with dynamic slicing and backtracking.pdf:application/pdf;Snapshot:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\4KSPWG25\\abstract.html:text/html}
}

@article{lieberman_zstep_1995,
	title = {{ZStep} 95: A Reversible, Animated Source Code Stepper},
	url = {http://130.203.133.150/viewdoc/versions;jsessionid=893D311F60B29FD557D247EA78CE8315?doi=10.1.1.54.4007&version=0},
	shorttitle = {{ZStep} 95},
	abstract = {{CiteSeerX} - Document Details (Isaac Councill, Lee Giles): this paper. It is important not only to "back up" variables to their previous values, but also to "back up" a consistent view of the user interface, including static code, dynamic data, and graphical output so that the user "backs up" their mental image of the program execution. The reversible control structure aspects of {ZStep} 95 are discussed in more detail in [9]. We will address the issue of the computational expense of the historykeeping mechanism later. {ZStep} 95's main menu uses a bi-directional "video recorder" metaphor. The single-arrow "play" and "reverse" correspond to single-step in a traditional stepper, and the "fast-forward" and "rewind" operation go from an expression to its value and vice versa, without displaying details.},
	author = {Lieberman, Henry and Fry, Christopher},
	urldate = {2013-01-20},
	date = {1995},
	keywords = {Christopher Fry, {CiteSeerX}, Henry Lieberman},
	file = {Snapshot:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\ES3HBZKT\\versions\;jsessionid=893D311F60B29FD557D247EA78CE8315.html:text/html}
}

@article{lewis_debugging_2003,
	title = {Debugging backwards in time},
	volume = {cs.{SE}/0310016},
	url = {http://arxiv.org/abs/cs/0310016},
	journaltitle = {Computing Research Repository},
	shortjournal = {{CoRR}},
	author = {Lewis, Bil},
	urldate = {2012-11-12},
	date = {2003},
	file = {Lewis 2003 - Debugging backwards in time.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\2A5NTWAT\\Lewis 2003 - Debugging backwards in time.pdf:application/pdf}
}

@inproceedings{pothier_scalable_2007,
	location = {New York, {NY}, {USA}},
	title = {Scalable omniscient debugging},
	isbn = {978-1-59593-786-5},
	url = {http://doi.acm.org/10.1145/1297027.1297067},
	doi = {10.1145/1297027.1297067},
	series = {{OOPSLA} '07},
	abstract = {Omniscient debuggers make it possible to navigate backwards in time within a program execution trace, drastically improving the task of debugging complex applications. Still, they are mostly ignored in practice due to the challenges raised by the potentially huge size of the execution traces. This paper shows that omniscient debugging can be realistically realized through the use of different techniques addressing efficiency, scalability and usability. We present {TOD}, a portable Trace-Oriented Debugger for Java, which combines an efficient instrumentation for event generation, a specialized distributed database for scalable storage and efficient querying, support for partial traces in order to reduce the trace volume to relevant events, and innovative interface components for interactive trace navigation and analysis in the development environment. Provided a reasonable infrastructure, the performance of {TOD} allows a responsive debugging experience in the face of large programs.},
	pages = {535--552},
	booktitle = {Proceedings of the 22nd annual {ACM} {SIGPLAN} conference on Object-oriented programming systems and applications},
	publisher = {{ACM}},
	author = {Pothier, Guillaume and Tanter, Éric and Piquer, José},
	urldate = {2013-01-20},
	date = {2007},
	keywords = {execution traces, interface components, omniscient debugging, partial traces, scalability, specialized distributed database},
	file = {Pothier, Tanter, Piquer 2007 - Scalable omniscient debugging.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\9FNZX7XD\\Pothier, Tanter, Piquer 2007 - Scalable omniscient debugging.pdf:application/pdf}
}

@incollection{lienhard_practical_2008,
	title = {Practical Object-Oriented Back-in-Time Debugging},
	rights = {©2008 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-70591-8 978-3-540-70592-5},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-70592-5_25},
	series = {Lecture Notes in Computer Science},
	abstract = {Back-in-time debuggers are extremely useful tools for identifying the causes of bugs. Unfortunately the “omniscient” approaches that try to remember all previous states are impractical because they consume too much space or they are far too slow. Several approaches rely on heuristics to limit these penalties, but they ultimately end up throwing out too much relevant information. In this paper we propose a practical approach that attempts to keep track of only the relevant data. In contrast to other approaches, we keep object history information together with the regular objects in the application memory. Although seemingly counter-intuitive, this approach has the effect that data not reachable from current application objects (and hence, no longer relevant) is garbage collected. We describe the technical details of our approach, and we present benchmarks that demonstrate that memory consumption stays within practical bounds. Furthermore, the performance penalty is significantly less than with other approaches.},
	pages = {592--615},
	number = {5142},
	booktitle = {{ECOOP} 2008 – Object-Oriented Programming},
	publisher = {Springer Berlin Heidelberg},
	author = {Lienhard, Adrian and Gîrba, Tudor and Nierstrasz, Oscar},
	editor = {Vitek, Jan},
	urldate = {2013-01-20},
	date = {2008-01-01},
	keywords = {Computer Communication Networks, Logics and Meanings of Programs, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Programming Techniques, software engineering},
	file = {Lienhard, Gîrba, Nierstrasz 2008 - Practical Object-Oriented Back-in-Time Debugging.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\KWU34VHK\\Lienhard, Gîrba, Nierstrasz 2008 - Practical Object-Oriented Back-in-Time Debugging.pdf:application/pdf;Snapshot:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\5MGNT3II\\10.html:text/html}
}

@article{perscheid_test-driven_2012,
	title = {Test-driven Fault Navigation for Debugging Reproducible Failures},
	volume = {29},
	pages = {188--211},
	number = {3},
	journaltitle = {Computer Software},
	author = {Perscheid, Michael and Haupt, Michael and Hirschfeld, Robert and Masuhara, Hidehiko},
	date = {2012},
	file = {Perscheid et al 2012 - Test-driven Fault Navigation for Debugging Reproducible Failures.pdf:C\:\\Users\\C5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\cdb6jfrx.default\\zotero\\storage\\VPF692T5\\Perscheid et al 2012 - Test-driven Fault Navigation for Debugging Reproducible Failures.pdf:application/pdf}
}

@inproceedings{treffer_dynamic_2014,
	location = {New York, {NY}, {USA}},
	title = {Dynamic Slicing with Soot},
	isbn = {978-1-4503-2919-4},
	url = {http://doi.acm.org/10.1145/2614628.2614631},
	doi = {10.1145/2614628.2614631},
	series = {{SOAP} '14},
	pages = {1--6},
	booktitle = {Proceedings of the 3rd {ACM} {SIGPLAN} International Workshop on the State of the Art in Java Program Analysis},
	publisher = {{ACM}},
	author = {Treffer, Arian and Uflacker, Matthias},
	date = {2014},
	keywords = {debugging, dynamic analysis, slicing, static analysis}
}