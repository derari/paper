% This is "sig-alternate.tex" V2.1 April 2013
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%

\documentclass[english]{sig-alternate-05-2015}



\usepackage{babel}
\usepackage{csquotes}
%\MakeAutoQuote{«}{»} %% "

%\usepackage[backend=biber,style=numeric-comp]{biblatex}
%\bibliography{references}
%\renewcommand{\bibliography}[1]{\printbibliography}

\usepackage{MnSymbol}

\usepackage[svgnames]{xcolor}
\usepackage{todonotes}

%\usepackage{makecell}
\usepackage{ctable}


%% === Code Listings ======================================
\usepackage{listings}

\newcommand{\lineref}[2]{\hyperref[#1]{line~\ref*{#1:#2}}}
\newcommand{\linerefn}[2]{\hyperref[#1]{line~#2}}
\newcommand{\linesrefn}[2]{\hyperref[#1]{lines~#2}}
\usepackage{accsupp}
\newcommand\emptyaccsupp[1]{\BeginAccSupp{ActualText={}}#1\EndAccSupp{}}

\usepackage{hyperref}
\usepackage[all]{hypcap}
\PassOptionsToPackage{nameinlink,noabbrev}{cleveref}
\usepackage{cleveref}


% \lstset{captionpos=b, xleftmargin=1cm}
% \lstset{basicstyle=\small\ttfamily, showstringspaces=false, columns=flexible, keepspaces=true}
\lstset{showstringspaces=false, columns=flexible, keepspaces=true}
\lstset{tabsize=2, gobble=2}
%\lstset{upquote=true}
%% Linebreaks
%\lstset{prebreak=\raisebox{0ex}[0ex][0ex]
%        {\ensuremath{\rhookswarrow}}}
\lstset{postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\rcurvearrowse\space}}}
\lstset{breaklines=true, breakatwhitespace=true}
%% Line Numbers
\newcommand{\lstnumberstyle}[1]{\tiny\emptyaccsupp{#1}}
\lstset{numbers=left, numberstyle=\lstnumberstyle, numbersep=5pt,
		numberfirstline=true, firstnumber=1, stepnumber=5}
\lstset{escapeinside={(*@}{@*)}}
\lstdefinestyle{BWStyle}{
	keywordstyle=\bfseries,
	stringstyle=\color{DimGray},
	commentstyle=\textsl,
}
\lstset{style=BWStyle}

\lstdefinelanguage{algorithm}{
	keywords={function, for, do, if, then, else, return, in_, is_a, or, and},
	morecomment=[l]{'},
	morecomment=[s]{/*}{*/},
	morestring=[b]",
	sensitive=true,
}
\lstdefinelanguage{HanaSQL}[]{SQL}{
	morekeywords={replace,string,if,is,daysbetween,secondsbetween,weekday,adddays,addseconds,double},
	moredelim=**[is][\slshape]{^}{^},
	moredelim=**[is][\bfseries]{§}{§},
}
\lstdefinelanguage{Inline}{
	moredelim=**[is][\slshape]{^}{^},
	moredelim=**[is][\bfseries]{§}{§},
}

\lstset{language=HanaSQL}
\lstMakeShortInline[basicstyle=\ttfamily,language={Inline},breaklines=true]°


\begin{document}

% Copyright
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\doi{10.475/123_4}

% ISBN
\isbn{123-4567-24-567/08/06}

%Conference
\conferenceinfo{PLDI '13}{June 16--19, 2013, Seattle, WA, USA}

\acmPrice{\$15.00}

%
% --- Author Metadata here ---
\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Tracing And Recorded Data In Stored Procedures }
\subtitle{subtitle}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} 
\author{
% 1st. author
\alignauthor
Ben Trovato\titlenote{Dr.~Trovato insisted his name be first.}\\
       \affaddr{Institute for Clarity in Documentation}\\
       \affaddr{1932 Wallamaloo Lane}\\
       \affaddr{Wallamaloo, New Zealand}\\
       \email{trovato@corporation.com}
% 2nd. author
\alignauthor
G.K.M. Tobin\titlenote{The secretary disavows
any knowledge of this author's actions.}\\
       \affaddr{Institute for Clarity in Documentation}\\
       \affaddr{P.O. Box 1212}\\
       \affaddr{Dublin, Ohio 43017-6221}\\
       \email{webmaster@marysville-ohio.com}
% 3rd. author
\alignauthor Lars Th{\o}rv{\"a}ld\titlenote{This author is the
one who did all the really hard work.}\\
       \affaddr{The Th{\o}rv{\"a}ld Group}\\
       \affaddr{1 Th{\o}rv{\"a}ld Circle}\\
       \affaddr{Hekla, Iceland}\\
       \email{larst@affiliation.org}
%\and  % use '\and' if you need 'another row' of author names
}

%\date{30 July 1999}

\maketitle
\begin{abstract}
  Omniscient debuggers can greatly improve developer productivity.
	Not only do they allow for more efficient navigation in the execution of a program,
	they can be used as a foundation for dynamic analyses that further help the developer to identify relevant parts of code.
	We present an approach of bringing omniscient debugging and advanced analysis algorithms to stored procedures.
	Our prototype allows omniscient debugging of SQLScript that handles large amounts of data, while creating only a small overhead by using an insert-only approach.
	Furthermore, we present an extension to SQL that allows the developer to express queries that cover a period of execution time.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>  
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

\printccsdesc

\keywords{ACM proceedings; \LaTeX; text tagging}

\section{Introduction}

Debugging is important, ODB in particular

tool support for code in db is needed more than ever

\section{Related Work}

\section{Omniscient Debugger Prototype}

- typical problem: much data \\
- backend: HANA xs-engine \\
- frontend: HTML5 \\

\todo[inline]{screenshot}

\subsection{Data Model}

To reproduce the execution of a stored procedure, we need to trace a sequence of execution steps.
Each step represents an instruction that has side effects or returns some result to the procedure.

A typical limitation for omniscient debuggers is the large amount of trace data generated when processing large data sets, which typically exceeds the program data by orders of magnitude.
Since our debugger is supposed to work with large databases, using an even bigger database just to manage debug sessions is not feasible.

Instead, we take advantage of the fact that all instructions handling large data sets, i.e., SQL statements, are declarative and reproducible as long as the underlying data does not change.
Thus, SQL queries don't have to be traced at all, although for some purposes it will be helpful to record some meta information, such as the execution time or the number of results.

\todo[inline]{Diagram}
- Traces \\
- Steps \\
- Queries \\
- QueryArgs \\

\subsection{Tracing}

With a debugger fully integrated in its database, we would expect the stored procedure execution engine to trace the execution steps.
However, for our prototype this level of integration was out of scope.

Instead, we wrote a Java program that parses a stored procedure and inserts INSERT statements around every instruction to fill the trace tables.

\todo[inline]{example}
\todo[inline]{also: generates functions/views for variables}

%% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsection{Reproducing Query Results}

By tracing all variables, the debugger has enough information available to re-execute any query.
However, the query will only yield the same results as long as the underlying data has not changed.

In general, one can expect that debugging will take place on a development machine where no other data manipulation occurs.
However, in cases where this assumption doesn't hold, the debugger might end up showing wrong or misleading data the developer, which can make the tool outright harmful.
Furthermore, the debugged stored procedure itself may change the data, which will cause a query to return different results at different points in time.

We have identified three strategies of dealing with data changes, each with its own advantages and disadvantages.

\paragraph{Temporary Tables}
Auxiliary tables can be used to track all data changes.
Values of deleted tuples and modified attributes have to be recorded, as well as timestamps of the manipulation events.
To re-execute a query, it has to be rewritten to include this additional data.

An advantage of this approach is that it allows to efficiently analyze the modifications that were applied by the stored procedure.
Disadvantages are that copying data to auxiliary tables greatly increases the tracing overhead, and that rewritten queries are much more complex and thus may take longer to execute.

\paragraph{Transactions}
If the whole debug session runs in a single database transaction, it is automatically protected from concurrent modifications.
Nested transactions can be used to rollback changes done by the debugged code.

This approach requires only little effort by the debugger, as it builds upon existing features of the database.
However, to re-execute a single query, the whole stored procedure has to be re-executed up until that point, which can create a significant overhead.
Furthermore, depending on how transactions are implemented, the developer might accidentally lock the database for everyone else.

\paragraph{Insert-Only}
In systems that are relevant to accounting, such as ERP, finance, and CRM systems, data is never deleted.
Such behavior often even is a legal requirement.
If we require for all tables that data can never be changed or deleted and annotate all tuples with timestamps of when they have been created and invalidated, we can reconstruct the state of the database of any point in time.

Especially in in-memory databases, the overhead can be less than expected due to compression, and it may even improve the performance as inserts can be faster than updates or deletes.
Finally, adding timestamp filters to select queries does not cause a significant slowdown.
Our prototype was built using this approach.
\section{Time-travel Queries}

In our set-up, the debugger trying to recreate intermediate results of a stored procedure is just a special use case for the ability to submit arbitrary queries against the database of any previous point in time.

\subsection{The Step Concept}

The query shown in \cref{lst:ttravel} selects the total of open orders for previously selected projects.
We will use it as an example to demonstrate how \emph{time-traveling} queries are handled by our system.

\begin{lstlisting}[language=HanaSQL,float,caption={Example for a time-travel query: select the current total of open orders for previously selected projects},label=lst:ttravel]
  SELECT pr.id, pr.name, pr.budget, SUM(po.total)
  FROM :selected_projects pr
	JOIN PurchaseOrders po ON po.project_id = pr.id
	WHERE po.status = 'open'
	GROUP BY pr.id, pr.name, pr.budget
	^§AT STEP§ 1623^
\end{lstlisting}

The last line shows an extension to SQL that can be used by the developer to explicitly query a point in time, with °^1623^° being a steo ID that was obtained from the debugger UI.
If omitted, the current step can be derived from the context from which the query is submitted, such as an SQL console that is associated with a specific point in time or the current debug step.
The parameter °:selected_projects° refers to a variable from the current debug session and will be populated with its current value, independently of the value of the step-clause.

When submitted, our debugger applies two changes to the query before it can be submitted to the database.
First, all variables are replaced with corresponding functions or views.
For variables containing atomic values, a function is generated that returns the variable's value at a given step.
For variables containing query results, a view is generated for each query.
These views are identified by the target variable name and the line number and expect a step number and all parameters that the actual query took.
\todo[inline]{explain variable functions}
In our example, °:selected_projects° might be replaced with °VAR_selected_projects_7(1055, 'Research')° when it was last set at step 1055 in code line 7 and called with the respective argument.

Second, a time-stamp filter is added for all tables that are referenced in the query. 
In our example,
\begin{lstlisting}[language={Inline},basicstyle=\ttfamily,numbers=none]
  po.createdOn < ^1623^ AND (po.validTo IS NULL OR po.validTo > ^1623^)
\end{lstlisting}
would be added to the Where-clause.

Now, the query can be submitted to the database and the result is subsequently presented to the user.

\subsection{Time-diff Queries}

\newcommand{\red}[1]{\textcolor{DarkRed}{#1}}
\newcommand{\gr}[1]{\textcolor{Green}{#1}}


\ctable[star,caption={Result of a time-diff query, with multiple values in some columns},label=tab:diffresult,doinside={}]
				{rlrrrlr}{}{
	pr.id & pr.name 	& pr.budget & total & po2.id & po2.status & po2.total \ML
	
				&					 & \red{1200} & \red{1500} &	 & \red{open} &						\NN
	1			& Project 1 & 200				& 500 			 & 1 & paid 			& 1000			\NN
				&						& \gr{-300} & \gr{0}		 &	 &						&						\ML

				&					 & \red{1200} & \red{1500} &	 & 						&						\NN
	1			& Project 1 & 200				& 500 			 & 2 & open 			& 500				\NN
				&						& \gr{-300} & \gr{0}		 &	 & \gr{paid}	&						\ML
}

To get a better overview about what happened in a piece of code, the developer might want to query multiple points in time at once and see the difference in the query result.
For this example, she debugs a stored procedure that processes the payments for projects, but sometimes allows projects to go over budget.
By stepping into the procedure, she has three defined points in time: °^before^°, at the beginning of the procedure; °^now^°, at the current instruction; and °^after^°, at the end of the execution.

Now she wants to compose a query that selects all projects that will go over budget and the orders that were processed.
\todo[inline]{explain query rewriting}
The query is shown in \cref{lst:tdiff}.
\begin{lstlisting}[language=HanaSQL,float=b,caption={Example of a time-diff query: "Select all projects that will go over budget and their respective purchase orders"},label=lst:tdiff]
	SELECT pr.id, pr.name, pr.budget, SUM(po.total), po2.id, po2.status, po2.total
	FROM :selectedProjects pr
	JOIN PurchaseOrders po ON po.project_id = pr.id
	JOIN PurchaseOrders po2 ON po2.project_id = pr.id
	WHERE po.status = 'open'
		AND now!pr.budget > 0 AND after!pr.budget < 0
		AND before!po2.status != after!po2.status
	GROUP BY pr.id, pr.name, pr.budget, po2.id, po2.status, po2.total
	^§AT STEP§ before=817, now=1623, after=2043^
\end{lstlisting}
Like before, the °^AT STEP^° clause does not have to be explicitly typed in the query, but can also be derived from the context.
A language extension allows to add filter conditions that only apply to specific points in time.
\Cref{tab:diffresult} shows a possible result for this query, with one project that goes over budget and two associated purchases, of which one was already processed.

To produce this result, the query has to be executed three times, once for each point in time, without the time-specific filter conditions.
Then, to prepare the diffing of the results, they are outer-joined on the primary keys and the time-specific filters are applied.
For performance reasons, all of this happens inside a single SQL query, as shown in \cref{lst:tdifffinal}.
The execution of the sub-queries is indicated in \linerefn{lst:tdifffinal}{6, 7, and 10}, the time-specific filters can be found in the Where-condition of \linerefn{lst:tdifffinal}{15 and 16}.

\begin{lstlisting}[language=HanaSQL,float,caption={Parts of the time-diff query after transformation},label=lst:tdifffinal]
	SELECT COALESCE(__before."pr.id", ...) AS "pr.id",
	       COALESCE(__before."po.id", ...) AS "po.id",
				 __before.createdOn as _step_0,
				 __before."pr_name" AS "pr_name_0", ...,
				 ...
	FROM (SELECT ... ^§AT STEP§ before^) __before
	FULL OUTER JOIN (SELECT ... ^§AT STEP§ now^) __now
	    ON __before."pr.id" = __now."pr.id" 
		 AND __before."po.id" = __now."po.id"
	FULL OUTER JOIN (SELECT ... ^§AT STEP§ after^) __after
	    ON (__before."pr.id" = __after."pr.id" 
		      AND __before."po.id" = __after."po.id")
		  OR (__now."pr.id" = __after."pr.id" 
		      AND __now."po.id" = __after."po.id")
	WHERE __now."pr.budget" > 0 AND __after."pr.budget" < 0
	  AND __before."po.status" != __after."po.status"
\end{lstlisting}

For the final result, the key attributes are coalesced while the other attributes are selected from each point in time.
Furthermore, for each tuple its creation step is selected.
This value is needed for two reasons: first, it is necessary to distinguish between tuples with °NULL° values and tuples completely missing from the result; second, it allows the debugger to know when the value was created or changed.

In the UI, the before and after values are only shown if they differ from the now value.
Clicking on value allows the developer to jump to the °UPDATE° or °INSERT° statement that caused the change.


\section{Evaluation}

- Test system: 2 billion records of point of sales data \\
- Stored procedure: calculate revenue and margin per week of current and last year \\
- Exec time: approx. 3 seconds; with tracing: no measurable overhead \\
- °SELECT * FROM :result°: 1.5 seconds \\
- \todo[inline]{time-diff queries}?

% bug-tracker 
% 


\subsection{Limitations}

Currently, our approach has two major limitations.

First, time-diff queries can only be executed on tables that have clearly defined primary keys, for key attributes are required to track a tuple's versions over time.
For a query like "Sum budgets per project category", it has to be clear that categories are the entities that keep their identity over time.
Here, an additional syntax extension could be used to convey this kind of information.

Second, it is currently not possible to use time qualifiers outside of the °WHERE° clause.


\section{Conclusion}

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{sigproc}  % sigproc.bib is the name of the Bibliography in this case

\end{document}
