
@inproceedings{dufour_*j:_2003,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '03},
	title = {{*J:} a tool for dynamic analysis of Java programs},
	isbn = {1-58113-751-6},
	shorttitle = {{*J}},
	url = {http://doi.acm.org/10.1145/949344.949425},
	doi = {10.1145/949344.949425},
	abstract = {We describe a complete system for gathering, computing and presenting dynamic metrics from Java programs. The system itself was motivated from our real goals in understanding program behaviour as compiler/runtime developers, and so solves a number of practical and difficult problems related to metric gathering and analysis.},
	urldate = {2013-01-28},
	booktitle = {Companion of the 18th annual {ACM} {SIGPLAN} conference on Object-oriented programming, systems, languages, and applications},
	publisher = {{ACM}},
	author = {Dufour, Bruno and Hendren, Laurie and Verbrugge, Clark},
	year = {2003},
	keywords = {dynamic metrics, execution traces, Java, profiling, Program Analysis, software metrics},
	pages = {306–307},
	file = {Dufour, Hendren, Verbrugge 2003 - J.pdf:D:\Users\derari\Documents\zotero\storage\CZZDEZWB\Dufour, Hendren, Verbrugge 2003 - J.pdf:application/pdf}
},

@inproceedings{binder_j:_2009,
	address = {New York, {NY}, {USA}},
	series = {{VMIL} '09},
	title = {{@J:} Towards Rapid Development of Dynamic Analysis Tools for the Java Virtual Machine},
	isbn = {978-1-60558-874-2},
	shorttitle = {{@J}},
	url = {http://doi.acm.org/10.1145/1711506.1711510},
	doi = {10.1145/1711506.1711510},
	abstract = {Many software-engineering tools for the Java Virtual Machine that perform some form of dynamic program analysis, such as profilers or debuggers, are implemented with low-level bytecode instrumentation techniques. While program manipulation at the bytecode level is very flexible, because the possible bytecode transformations are not restricted, tool development is tedious and error-prone. Specifying bytecode instrumentation at a higher level using aspect-oriented programming ({AOP)} is a promising alternative in order to reduce tool development time and cost. However, prevailing {AOP} frameworks lack some features that are essential for certain dynamic analyses. In this paper, we focus on three common shortcomings in {AOP} frameworks with respect to the development of aspect-based tools -- (1) the lack of mechanisms for passing data between woven advices in local variables, (2) the support for user-defined static analyses at weaving time, and (3) the absence of pointcuts at the level of individual basic blocks of code. We propose {@J}, an annotation-based {AOP} language and weaver that integrates support for these three features. We illustrate the benefits of the proposed features with two examples.},
	urldate = {2014-03-12},
	booktitle = {Proceedings of the Third Workshop on Virtual Machines and Intermediate Languages},
	publisher = {{ACM}},
	author = {Binder, Walter and Villazón, Alex and Ansaloni, Danilo and Moret, Philippe},
	year = {2009},
	keywords = {analysis at weaving time, aspect weaving, aspect-oriented programming, basic-block-of-code pointcuts, bytecode instrumentation, Debugging, dynamic program analysis, Java Virtual Machine, local variables, profiling},
	pages = {4:1–4:9},
	file = {Binder et al 2009 - @J.pdf:D:\Users\derari\Documents\zotero\storage\BF9S23MR\Binder et al 2009 - @J.pdf:application/pdf}
},

@article{lewis_debugging_2003,
	title = {Debugging backwards in time},
	volume = {{cs.SE/0310016}},
	url = {http://arxiv.org/abs/cs/0310016},
	urldate = {2012-11-12},
	journal = {Computing Research Repository},
	author = {Lewis, Bil},
	year = {2003},
	file = {Lewis 2003 - Debugging backwards in time.pdf:D:\Users\derari\Documents\zotero\storage\2A5NTWAT\Lewis 2003 - Debugging backwards in time.pdf:application/pdf}
},

@inproceedings{ko_debugging_2008,
	address = {New York, {NY}, {USA}},
	series = {{ICSE} '08},
	title = {Debugging reinvented: asking and answering why and why not questions about program behavior},
	isbn = {978-1-60558-079-1},
	shorttitle = {Debugging reinvented},
	url = {http://doi.acm.org/10.1145/1368088.1368130},
	doi = {10.1145/1368088.1368130},
	abstract = {When software developers want to understand the reason for a program's behavior, they must translate their questions about the behavior into a series of questions about code, speculating about the causes in the process. The Whyline is a new kind of debugging tool that avoids such speculation by instead enabling developers to select a question about program output from a set of why did and why didn't questions derived from the program's code and execution. The tool then finds one or more possible explanations for the output in question, using a combination of static and dynamic slicing, precise call graphs, and new algorithms for determining potential sources of values and explanations for why a line of code was not reached. Evaluations of the tool on one task showed that novice programmers with the Whyline were twice as fast as expert programmers without it. The tool has the potential to simplify debugging in many software development contexts.},
	urldate = {2013-01-19},
	booktitle = {Proceedings of the 30th international conference on Software engineering},
	publisher = {{ACM}},
	author = {Ko, Andrew J. and Myers, Brad A.},
	year = {2008},
	keywords = {whyline},
	pages = {301–310},
	annote = {allows developers to ask a set of “why did” and “why didn’t” questions about the entireexecution history. Based on static and dynamic slicing, call trees, and several otheralgorithms, the approach can answer, for example, why a line of code has not been reached.},
	annote = {References
[7] Ko, {A.J.} {DeLine}, R., \& Venolia, G. (2007). Information needs in collocated software development teams. International Conference on Software Engineering, Minneapolis, {MN}, 344-353.

  And yet, despite decades of knowing that program understanding and debugging are some of the most challenging and time consuming aspects of software development, little has changed in how people work: these tasks still represent up to 70\% of the time required to ship a software product
  evidence that bug fixing is generally a collaborative process [7], which could benefit from the ability to share executions of failures
  Our studies also suggest that developers find concrete values essential for interpreting program state [7,8,10].

[10] Ko. {A.J.}, Myers, {B.A.}, Coblenz, M. \& Aung, {H.H.} (2006). An exploratory study of how developers seek, relate, and collect relevant information during software maintenance tasks. {IEEE} Transactions on Software Engineering, 32(12), 971-987.

  developers basically have to guess about what code is responsible
   why notquestions about things that did not happen; such questions are often the majority of developers’ questions

[11] Lencevicius R., Holzle U., \& Singh {A.K.} (2003). Dynamic query-based debugging of object-oriented Programs, Journal of Automated Software Engineering, 10(1), 367-370.[2] Baowen X., Ju Q., Xiaofang Z., Zhongqiang W., \& Lin C. (2005). A brief survey of program slicing, {SIGSOFT} Software Engineering Notes, 30, 2, 1-36.

Breakpoint debuggers  require people to choose a line of code. Slicing tools require a choice of variable [2]. Querying tools require a person to write an executable expression about data [11].

[8] Ko, {A.J.} \& Myers, {B.A.} (2004). Designing the Whyline: a debugging interface for asking questions about program failures. {ACM} Conference on Human Factors in Computing Systems, Vienna, Austria, 151-158.

  The Alice Whyline [8] supported a similar interaction technique, but for an extremely simple language with little need for procedures and a rigid definition of output (in a lab study, the Whyline for Alice decreased debugging time by a factor of 8).

[14] Myers {B.A.}, Weitzman D., Ko {A.J.}, \& Chau D. H. (2006). Answering why and why not questions in user interfaces. {ACM} Conference on Human Factors in Computing Systems, Montreal, Canada, 397-406.  The Crystal framework [14], which supported questions in end-user applications, applied the same ideas, but limited the scope mostly to questions about commands and events that appear in an application’s undo stack (in lab studies of Crystal, participants were able to complete 30\% more tasks, 20\% faster).[4] Cleve H. \& Zeller A. (2005). Locating causes of program failures. International Conference on Software {Engineering,St.} Louis, {MI}, 342-351.  automated debuggers, which take a specification of correctness and find an cause [4][19] Wang T. \& Roychoudhury A. (2004). Using compressed bytecode traces for slicing Java programs, International Conference on Software Engineering, Scotland, {UK}, 512-521.[20] Zhang X. \& Gupta R. (2005). Whole execution traces and their applications. {ACM} Transactions on Architecture and Code Optimization, 2(3), 301-334  a post mortemapproach to debugging, capturing a trace [19,20] and then analyzing it after the program has {stopped11.REFERENCES[1]} Abraham R. \& Erwig M. (2005). Goal-directed debugging of spreadsheets, {IEEE} Symposium on Visual Languages and Human-Centric Computing, Dallas, Texas, 37-44.[3] Clause J. \& Orso A. (2007). A technique for enabling and supporting debugging of field failures, International Conference on Software Engineering, Minneapolis, {MN}, 261-270.[5] Cooper {K.D.}, Harvey {T.J.} \& Kennedy K. (2001). A simple, fast dominance algorithm. Available at http://www.hipersoft.rice.edu/grads/publications/dom14.pdf.[6] Eisenberg A. \& De Volder K. (2005). Dynamic feature traces: finding features in unfamiliar code. International Conference on Software Maintenance, Budapest, Hungary, 337-346.[9] Ko. A. J., Myers, {B.A.}, Chau, {D.H.} (2006). A linguistic analysis of how people describe software problems. {IEEE} Visual Languages and Human-Centric Computing, Brighton, {UK}, 127-134.[11] Lencevicius R., Holzle U., \& Singh {A.K.} (2003). Dynamic query-based debugging of object-oriented Programs, Journal of Automated Software Engineering, 10(1), 367-370.[12] Lewis B. (2003). Debugging backwards in time, International Workshop on Automated Debugging, 225-235.[13] Liblit B., Naik M., Zheng A., Aiken A. \& Jordan M. (2005). Scalable statistical bug isolation. Programming Design and Implementation, Chicago, {IL}, {USA}, 15-26.[15] Potanin A., Noble J., \& Biddle R. (2004). Snapshot query-based debugging. Australian Software Engineering Conference, 251.[16] Sridharan M., Fink {S.J.}, \& Bodik R. (2007). Thin slicing. Programming Language Design and Implementation, San Diego, {CA}, 112-122.[17] Tassey, G. (2002). The economic impacts of inadequate infrastructure for software testing. National Institute of Standards and Technology, {RTI} Project Number 7007.011, 2002.[18] Ungar D., Lieberman H., \& Fry C. (1997). Debugging and the experience of immediacy. Communications of the {ACM}, 40(4) 39-43.},
	file = {Ko, Myers 2008 - Debugging reinvented.pdf:D:\Users\derari\Documents\zotero\storage\XTWCPHAM\Ko, Myers 2008 - Debugging reinvented.pdf:application/pdf}
},

@article{agrawal_debugging_1993,
	title = {Debugging with dynamic slicing and backtracking},
	volume = {23},
	copyright = {Copyright © 1993 John Wiley \& Sons, Ltd},
	issn = {1097-{024X}},
	url = {http://onlinelibrary.wiley.com/doi/10.1002/spe.4380230603/abstract},
	doi = {10.1002/spe.4380230603},
	abstract = {Programmers spend considerable time debugging code. Symbolic debuggers provide some help but the task remains complex and difficult. Other than breakpoints and tracing, these tools provide little high-level help. Programmers must perform many tasks manually that the tools could perform automatically, such as finding which statements in the program affect the value of an output variable for a given test case, and what was the value of a given variable when the control last reached a given program location. If debugging tools provided explicit support for these tasks, the debugging process could be automated to a significant {extent.In} this paper we present a debugging model, based on dynamic program slicing and execution backtracking techniques, that easily lends itself to automation. This model is based on experience with using these techniques to debug software. We also present a prototype debugging tool, {SPYDER}, that explicitly supports the proposed model, and with which we are performing further debugging research.},
	language = {en},
	number = {6},
	urldate = {2013-01-20},
	journal = {Software: Practice and Experience},
	author = {Agrawal, Hiralal and Demillo, Richard A. and Spafford, Eugene H.},
	year = {1993},
	keywords = {Dynamic program slicing, Execution backtracking, program debugging, Program slicing, Reverse program execution},
	pages = {589–616},
	annote = {combines dynamic slicing and backtrackingto identify causes and effects between statements and state. While automated dynamicslicing determines affected statements [8], backtracking restores program states fromre-executed checkpoints at previously defined breakpoints},
	file = {Agrawal, Demillo, Spafford 1993 - Debugging with dynamic slicing and backtracking.pdf:D:\Users\derari\Documents\zotero\storage\9BT38VTM\Agrawal, Demillo, Spafford 1993 - Debugging with dynamic slicing and backtracking.pdf:application/pdf;Snapshot:D:\Users\derari\Documents\zotero\storage\4KSPWG25\abstract.html:text/html}
},

@book{hammacher_design_2008,
	title = {Design and Implementation of an Efficient Dynamic Slicer for Java},
	publisher = {Saarland University},
	author = {Hammacher, Clemens},
	month = nov,
	year = {2008},
	note = {Published: Bachelor's Thesis}
},

@inproceedings{agrawal_dynamic_1990,
	address = {New York, {NY}, {USA}},
	series = {{PLDI} '90},
	title = {Dynamic Program Slicing},
	isbn = {0-89791-364-7},
	url = {http://doi.acm.org/10.1145/93542.93576},
	doi = {10.1145/93542.93576},
	abstract = {Program slices are useful in debugging, testing, maintenance, and understanding of programs. The conventional notion of a program slice, the static slice, is the set of all statements that might affect the value of a given variable occurrence. In this paper, we investigate the concept of the dynamic slice consisting of all statements that actually affect the value of a variable occurrence for a given program input. The sensitivity of dynamic slicing to particular program inputs makes it more useful in program debugging and testing than static slicing. Several approaches for computing dynamic slices are examined. The notion of a Dynamic Dependence Graph and its use in computing dynamic slices is discussed. The Dynamic Dependence Graph may be unbounded in length; therefore, we introduce the economical concept of a Reduced Dynamic Dependence Graph, which is proportional in size to the number of dynamic slices arising during the program execution.},
	urldate = {2014-03-12},
	booktitle = {Proceedings of the {ACM} {SIGPLAN} 1990 Conference on Programming Language Design and Implementation},
	publisher = {{ACM}},
	author = {Agrawal, Hiralal and Horgan, Joseph R.},
	year = {1990},
	pages = {246–256},
	file = {Agrawal, Horgan 1990 - Dynamic Program Slicing.pdf:D:\Users\derari\Documents\zotero\storage\37QA6ESG\Agrawal, Horgan 1990 - Dynamic Program Slicing.pdf:application/pdf}
},

@article{korel_dynamic_1990,
	title = {Dynamic slicing of computer programs},
	volume = {13},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/0164121290900943},
	doi = {10.1016/0164-1212(90)90094-3},
	number = {3},
	urldate = {2014-03-13},
	journal = {Journal of Systems and Software},
	author = {Korel, Bogdan and Laski, Janusz},
	month = nov,
	year = {1990},
	pages = {187--195},
	file = {ScienceDirect Snapshot:D:\Users\derari\Documents\zotero\storage\XHXW67QB\0164121290900943.html:text/html}
},

@inproceedings{szegedi_dynamic_2005,
	title = {Dynamic slicing of Java bytecode programs},
	doi = {10.1109/SCAM.2005.8},
	abstract = {A forward global method for obtaining backward dynamic slices of Java bytecode programs is presented. In contrast with existing published techniques that require either a customized Java compiler (which also implies access to the source code) or bytecode instrumentation and eventual manual dependency specifications, our approach was to produce an instrumented virtual machine for Java. This approach works with programs compiled with arbitrary third party compilers and does not require access to the source code during the slicing process. However, we still retain the ability to express the slicing criterion and the resulting slice in terms of source code locations using the supplemental information present in the compiled code. Our technique also handles advanced aspects of the Java environment, such as exception handling, multithreaded execution and, to a certain degree, the execution of native machine code linked with the Java classes.},
	booktitle = {Fifth {IEEE} International Workshop on Source Code Analysis and Manipulation, 2005},
	author = {Szegedi, A. and Gyimothy, T.},
	month = sep,
	year = {2005},
	keywords = {Concrete, Conferences, Debugging, Dynamic program slicing, Instruments, Java, Java bytecode programs, Manuals, program compilers, Program processors, Program slicing, software engineering, source code locations, virtual machine, Virtual machining},
	pages = {35--44},
	file = {IEEE Xplore Abstract Record:D:\Users\derari\Documents\zotero\storage\TZ5VVPN3\login.html:text/html}
},

@article{wang_dynamic_2008,
	title = {Dynamic Slicing on Java Bytecode Traces},
	volume = {30},
	issn = {0164-0925},
	url = {http://doi.acm.org/10.1145/1330017.1330021},
	doi = {10.1145/1330017.1330021},
	abstract = {Dynamic slicing is a well-known technique for program analysis, debugging and understanding. Given a program P and input I, it finds all program statements which directly/indirectly affect the values of some variables' occurrences when P is executed with I. In this article, we develop a dynamic slicing method for Java programs. Our technique proceeds by backwards traversal of the bytecode trace produced by an input I in a given program P. Since such traces can be huge, we use results from data compression to compactly represent bytecode traces. The major space savings in our method come from the optimized representation of (a) data addresses used as operands by memory reference bytecodes, and (b) instruction addresses used as operands by control transfer bytecodes. We show how dynamic slicing algorithms can directly traverse our compact bytecode traces without resorting to costly decompression. We also extend our dynamic slicing algorithm to perform “relevant slicing”. The resultant slices can be used to explain omission errors that is, why some events did not happen during program execution. Detailed experimental results on space/time overheads of tracing and slicing are reported in the article. The slices computed at the bytecode level are translated back by our tool to the source code level with the help of information available in Java class files. Our {JSlice} dynamic slicing tool has been integrated with the Eclipse platform and is available for usage in research and development.},
	number = {2},
	urldate = {2014-03-13},
	journal = {{ACM} Trans. Program. Lang. Syst.},
	author = {Wang, Tao and Roychoudhury, Abhik},
	month = mar,
	year = {2008},
	keywords = {Debugging, Program slicing, tracing},
	pages = {10:1–10:49},
	file = {Wang, Roychoudhury 2008 - Dynamic Slicing on Java Bytecode Traces.pdf:D:\Users\derari\Documents\zotero\storage\2SZPIKRM\Wang, Roychoudhury 2008 - Dynamic Slicing on Java Bytecode Traces.pdf:application/pdf}
},

@inproceedings{feldman_igor:_1988,
	address = {New York, {NY}, {USA}},
	series = {{PADD} '88},
	title = {{IGOR:} a system for program debugging via reversible execution},
	isbn = {0-89791-296-9},
	shorttitle = {{IGOR}},
	url = {http://doi.acm.org/10.1145/68210.69226},
	doi = {10.1145/68210.69226},
	abstract = {Typical debugging tools are insufficiently powerful to find the most difficult types of program misbehaviors. We have implemented a prototype of a new debugging system, {IGOR}, which provides a great deal more useful information and offers new abilities that are quite promising. The system runs fast enough to be quite useful while providing many features that are usually available only in an interpreted environment. We describe here some improved facilities (reverse execution, selective searching of execution history, substitution of data and executable parts of the programs) that are needed for serious debugging and are not found in traditional single-thread debugging tools. With a little help from the operating system, we provide these capabilities at reasonable cost without modifying the executable code and running fairly close to full speed. The prototype runs under the {DUNE} distributed operating system.
The current system only supports debugging of single-thread programs. The paper describes planned extensions to make use of extra processors to speed the system and for applying the technique to multi-thread and time dependent executions.},
	urldate = {2013-01-20},
	booktitle = {Proceedings of the 1988 {ACM} {SIGPLAN} and {SIGOPS} workshop on Parallel and distributed debugging},
	publisher = {{ACM}},
	author = {Feldman, Stuart I. and Brown, Channing B.},
	year = {1988},
	pages = {112–123},
	annote = {delegates the process of checkpointingto the operating system that then incrementally stores memory snapshots. With thisexpensive method, it allows reverse execution, selective searching of past data, and thesubstitution of program entities.},
	file = {Feldman, Brown 1988 - IGOR.pdf:D:\Users\derari\Documents\zotero\storage\H2C7AANJ\Feldman, Brown 1988 - IGOR.pdf:application/pdf}
},

@incollection{lienhard_practical_2008,
	series = {Lecture Notes in Computer Science},
	title = {Practical Object-Oriented Back-in-Time Debugging},
	copyright = {©2008 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-540-70591-8, 978-3-540-70592-5},
	url = {http://link.springer.com/chapter/10.1007/978-3-540-70592-5_25},
	abstract = {Back-in-time debuggers are extremely useful tools for identifying the causes of bugs. Unfortunately the “omniscient” approaches that try to remember all previous states are impractical because they consume too much space or they are far too slow. Several approaches rely on heuristics to limit these penalties, but they ultimately end up throwing out too much relevant information. In this paper we propose a practical approach that attempts to keep track of only the relevant data. In contrast to other approaches, we keep object history information together with the regular objects in the application memory. Although seemingly counter-intuitive, this approach has the effect that data not reachable from current application objects (and hence, no longer relevant) is garbage collected. We describe the technical details of our approach, and we present benchmarks that demonstrate that memory consumption stays within practical bounds. Furthermore, the performance penalty is significantly less than with other approaches.},
	number = {5142},
	urldate = {2013-01-20},
	booktitle = {{ECOOP} 2008 – Object-Oriented Programming},
	publisher = {Springer Berlin Heidelberg},
	author = {Lienhard, Adrian and Gîrba, Tudor and Nierstrasz, Oscar},
	editor = {Vitek, Jan},
	month = jan,
	year = {2008},
	keywords = {Computer Communication Networks, Logics and Meanings of Programs, Management of Computing and Information Systems, Programming Languages, Compilers, Interpreters, Programming Techniques, software engineering},
	pages = {592--615},
	annote = {in conjunction with object aliases also allowsfor a practical back in time debugger. The approach leverages the virtual machine andits garbage collector to remove no longer reachable objects and to discard correspondingevents. Tracing is fast and memory consumption is low but it requires an adapted virtualmachine and discarding events limit the approach because failure causes might be includedin objects that are no longer in use.},
	file = {Lienhard, Gîrba, Nierstrasz 2008 - Practical Object-Oriented Back-in-Time Debugging.pdf:D:\Users\derari\Documents\zotero\storage\KWU34VHK\Lienhard, Gîrba, Nierstrasz 2008 - Practical Object-Oriented Back-in-Time Debugging.pdf:application/pdf;Snapshot:D:\Users\derari\Documents\zotero\storage\5MGNT3II\10.html:text/html}
},

@inproceedings{zhang_precise_2003,
	title = {Precise dynamic slicing algorithms},
	doi = {10.1109/ICSE.2003.1201211},
	abstract = {Dynamic slicing algorithms can greatly reduce the debugging effort by focusing the attention of the user on a relevant subset of program statements. In this paper we present the design and evaluation of three precise dynamic slicing algorithms called the full preprocessing ({FP)}, no preprocessing ({NP)} and limited preprocessing ({LP)} algorithms. The algorithms differ in the relative timing of constructing the dynamic data dependence graph and its traversal for computing requested dynamic slices. Our experiments show that the {LP} algorithm is a fast and practical precise slicing algorithm. In fact we show that while precise slices can be orders of magnitude smaller than imprecise dynamic slices, for small number of slicing requests, the {LP} algorithm is faster than an imprecise dynamic slicing algorithm proposed by Agrawal and Horgan.},
	booktitle = {25th International Conference on Software Engineering, 2003. Proceedings},
	author = {Zhang, Xiangyu and Gupta, R. and Zhang, Youtao},
	month = may,
	year = {2003},
	keywords = {Algorithm design and analysis, computational complexity, Computer aided instruction, Computer science, Costs, Data analysis, Debugging, dynamic data dependence graph, full preprocessing algorithm, graph theory, Heuristic algorithms, limited preprocessing algorithm, no preprocessing algorithm, precise dynamic slicing algorithms, Program slicing, Sequential analysis, software engineering, Timing},
	pages = {319--329},
	file = {IEEE Xplore Abstract Record:D:\Users\derari\Documents\zotero\storage\Z96HDIAD\login.html:text/html;Zhang, Gupta, Zhang 2003 - Precise dynamic slicing algorithms.pdf:D:\Users\derari\Documents\zotero\storage\58UVHBWG\Zhang, Gupta, Zhang 2003 - Precise dynamic slicing algorithms.pdf:application/pdf}
},

@article{weiser_programmers_1982,
	title = {Programmers use slices when debugging},
	volume = {25},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/358557.358577},
	doi = {10.1145/358557.358577},
	abstract = {Computer programmers break apart large programs into smaller coherent pieces. Each of these pieces: functions, subroutines, modules, or abstract datatypes, is usually a contiguous piece of program text. The experiment reported here shows that programmers also routinely break programs into one kind of coherent piece which is not coniguous. When debugging unfamiliar programs programmers use program pieces called slices which are sets of statements related by their flow of data. The statements in a slice are not necessarily textually contiguous, but may be scattered through a program.},
	number = {7},
	urldate = {2013-10-29},
	journal = {Commun. {ACM}},
	author = {Weiser, Mark},
	month = jul,
	year = {1982},
	keywords = {program decomposition, slice},
	pages = {446–452},
	file = {Weiser 1982 - Programmers use slices when debugging.pdf:D:\Users\derari\Documents\zotero\storage\GANHC29M\Weiser 1982 - Programmers use slices when debugging.pdf:application/pdf;Weiser 1982 - Programmers use slices when debugging.pdf:D:\Users\derari\Documents\zotero\storage\3STUGDS6\Weiser 1982 - Programmers use slices when debugging.pdf:application/pdf}
},

@inproceedings{pothier_scalable_2007,
	address = {New York, {NY}, {USA}},
	series = {{OOPSLA} '07},
	title = {Scalable omniscient debugging},
	isbn = {978-1-59593-786-5},
	url = {http://doi.acm.org/10.1145/1297027.1297067},
	doi = {10.1145/1297027.1297067},
	abstract = {Omniscient debuggers make it possible to navigate backwards in time within a program execution trace, drastically improving the task of debugging complex applications. Still, they are mostly ignored in practice due to the challenges raised by the potentially huge size of the execution traces. This paper shows that omniscient debugging can be realistically realized through the use of different techniques addressing efficiency, scalability and usability. We present {TOD}, a portable Trace-Oriented Debugger for Java, which combines an efficient instrumentation for event generation, a specialized distributed database for scalable storage and efficient querying, support for partial traces in order to reduce the trace volume to relevant events, and innovative interface components for interactive trace navigation and analysis in the development environment. Provided a reasonable infrastructure, the performance of {TOD} allows a responsive debugging experience in the face of large programs.},
	urldate = {2013-01-20},
	booktitle = {Proceedings of the 22nd annual {ACM} {SIGPLAN} conference on Object-oriented programming systems and applications},
	publisher = {{ACM}},
	author = {Pothier, Guillaume and Tanter, Éric and Piquer, José},
	year = {2007},
	keywords = {execution traces, interface components, omniscient debugging, partial traces, scalability, specialized distributed database},
	pages = {535–552},
	annote = {ombines anefficient instrumentation mechanism and a specialized distributed database for capturingexhaustive traces. This approach requires considerable infrastructure and set-up costs,and moreover imposes a high run-time overhead and resource requirements. Later, a novelindexing and querying technique [168] ensures scalability to arbitrarily large executiontraces and offers an interactive debugging experience that outperforms existing back intime debuggers.},
	file = {Pothier, Tanter, Piquer 2007 - Scalable omniscient debugging.pdf:D:\Users\derari\Documents\zotero\storage\9FNZX7XD\Pothier, Tanter, Piquer 2007 - Scalable omniscient debugging.pdf:application/pdf}
},

@book{arvind_slicing_2006,
	title = {Slicing of Java Programs using the Soot Framework},
	abstract = {Slicing is a technique used to identify the program subset that could affect a particular statement of interest called the slicing criterion. Slicing has applications in program understanding, testing, model checking and functionality extraction. For computing a slice, we need to compute dependence information among statements. In object oriented languages, finding dependence information becomes non-trivial because of language features like inheritance, objects, polymorphism, dynamic binding and so forth. We develop a method for computing slices in object oriented programs for application in regression testing. In particular we propose a new method for intraprocedural alias analysis for Java and implement an interprocedural slicing technique using the system dependence graph of Horwitz et al. 1},
	author = {Arvind, D. and Shankar, Priti},
	year = {2006},
	file = {Arvind, Shankar 2006 - Slicing of Java Programs using the Soot Framework.pdf:D:\Users\derari\Documents\zotero\storage\9MPVZSUF\Arvind, Shankar 2006 - Slicing of Java Programs using the Soot Framework.pdf:application/pdf;Citeseer - Snapshot:D:\Users\derari\Documents\zotero\storage\M5D7W56U\summary.html:text/html}
},

@inproceedings{lam_soot_2011,
	address = {Galveston Island, {TX}},
	title = {The Soot framework for Java program analysis: a retrospective},
	booktitle = {Cetus Users and Compiler Infrastructure Workshop},
	author = {Lam, Patrick and Bodden, Eric and Lhoták, Ondřej and Hendren, Laurie},
	month = oct,
	year = {2011}
},

@article{binkley_theoretical_2006,
	title = {Theoretical foundations of dynamic program slicing},
	volume = {360},
	issn = {0304-3975},
	url = {http://www.sciencedirect.com/science/article/pii/S030439750600020X},
	doi = {http://dx.doi.org/10.1016/j.tcs.2006.01.012},
	number = {1–3},
	journal = {Theoretical Computer Science},
	author = {Binkley, Dave and Danicic, Sebastian and Gyimóthy, Tibor and Harman, Mark and Kiss, Ákos and Korel, Bogdan},
	year = {2006},
	keywords = {Dynamic, slicing},
	pages = {23 -- 41},
	file = {Binkley et al 2006 - Theoretical foundations of dynamic program slicing.pdf:D:\Users\derari\Documents\zotero\storage\4G8NZVDJ\Binkley et al 2006 - Theoretical foundations of dynamic program slicing.pdf:application/pdf}
}

@inproceedings{de_lucia_program_2001,
	title = {Program slicing: methods and applications},
	shorttitle = {Program slicing},
	doi = {10.1109/SCAM.2001.972675},
	abstract = {Program slicing is a viable method to restrict the focus of a task to specific sub-components of a program. Examples of applications include debugging, testing, program comprehension, restructuring, downsizing, and parallelization. The paper discusses different statement deletion based slicing methods, together with algorithms and applications to software engineering},
	booktitle = {First {IEEE} International Workshop on Source Code Analysis and Manipulation, 2001. Proceedings},
	author = {De Lucia, A.},
	year = {2001},
	keywords = {Application software, bibliographies, computer applications, Data flow computing, Debugging, downsizing, Equations, parallelization, program comprehension, program debugging, program restructuring, Program slicing, program sub-components, program testing, Programming profession, reverse engineering, Software algorithms, software engineering, statement deletion based slicing methods, Testing},
	pages = {142--149},
	file = {IEEE Xplore Abstract Record:D:\Users\derari\Documents\zotero\storage\EPTIMI8G\login.html:text/html}
}


@book{hoffner_evaluation_1995,
	title = {Evaluation and comparison of program slicing tools},
	url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.219.6109&rep=rep1&type=pdf},
	urldate = {2014-03-20},
	publisher = {Citeseer},
	author = {Hoffner, Tommy},
	year = {1995},
	file = {Hoffner 1995 - Evaluation and comparison of program slicing tools.pdf:D:\Users\derari\Documents\zotero\storage\QHEUR527\Hoffner 1995 - Evaluation and comparison of program slicing tools.pdf:application/pdf}
}

@book{plattner2011memory,
  title={In-Memory Data Management: An Inflection Point for Enterprise Applications},
  author={Plattner, H. and Zeier, A.},
  isbn={9783642193620},
  url={http://books.google.de/books?id=YDB2lf9PZKwC},
  year={2011},
  publisher={Springer}
}

@article{Hofer2006,
annote = {Tracing creates too much data.},
author = {Hofer, Christoph and Denker, Marcus and Ducasse, St\'{e}phane},
file = {:C$\backslash$:/Users/derari/Documents/Mendeley/Hofer, Denker, Ducasse - 2006 - Design and implementation of a backward-in-time debugger.pdf:pdf},
journal = {NODe 2006},
pages = {17--32},
title = {{Design and implementation of a backward-in-time debugger}},
url = {http://hal.archives-ouvertes.fr/inria-00555768/},
year = {2006}
}
@inproceedings{Lieberman1987,
	series = {Lecture Notes in Computer Science},
	title = {Reversible Object-Oriented Interpreters},
	volume = {276},
	isbn = {978-3-540-18353-2},
	url = {http://dx.doi.org/10.1007/3-540-47891-4_2},
	language = {English},
	booktitle = {{ECOOP’} 87 European Conference on Object-Oriented Programming},
	publisher = {Springer Berlin/Heidelberg},
	author = {Lieberman, Henry},
	year = {1987},
	pages = {11--19},
	file = {Lieberman 1987 - Reversible Object-Oriented Interpreters.pdf:D:\Users\derari\Documents\zotero\storage\KVFAP5X4\Lieberman 1987 - Reversible Object-Oriented Interpreters.pdf:application/pdf}

}

@inproceedings{Pagh:2005:OBF:1070432.1070548,
 author = {Pagh, Anna and Pagh, Rasmus and Rao, S. Srinivasa},
 title = {An Optimal Bloom Filter Replacement},
 booktitle = {Proceedings of the Sixteenth Annual ACM-SIAM Symposium on Discrete Algorithms},
 series = {SODA '05},
 year = {2005},
 isbn = {0-89871-585-7},
 location = {Vancouver, British Columbia},
 pages = {823--829},
 numpages = {7},
 url = {http://dl.acm.org/citation.cfm?id=1070432.1070548},
 acmid = {1070548},
 publisher = {Society for Industrial and Applied Mathematics},
 address = {Philadelphia, PA, USA},
} 