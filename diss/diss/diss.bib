
@article{agrawal_debugging_1993,
	title = {Debugging with dynamic slicing and backtracking},
	volume = {23},
	rights = {Copyright © 1993 John Wiley \& Sons, Ltd},
	issn = {1097-024X},
	url = {http://onlinelibrary.wiley.com/doi/10.1002/spe.4380230603/abstract},
	doi = {10.1002/spe.4380230603},
	abstract = {Programmers spend considerable time debugging code. Symbolic debuggers provide some help but the task remains complex and difficult. Other than breakpoints and tracing, these tools provide little high-level help. Programmers must perform many tasks manually that the tools could perform automatically, such as finding which statements in the program affect the value of an output variable for a given test case, and what was the value of a given variable when the control last reached a given program location. If debugging tools provided explicit support for these tasks, the debugging process could be automated to a significant extent.In this paper we present a debugging model, based on dynamic program slicing and execution backtracking techniques, that easily lends itself to automation. This model is based on experience with using these techniques to debug software. We also present a prototype debugging tool, {SPYDER}, that explicitly supports the proposed model, and with which we are performing further debugging research.},
	pages = {589--616},
	number = {6},
	journaltitle = {Software: Practice and Experience},
	author = {Agrawal, Hiralal and Demillo, Richard A. and Spafford, Eugene H.},
	urldate = {2013},
	date = {1993},
	langid = {english},
	keywords = {Dynamic program slicing, Execution backtracking, program debugging, Program slicing, Reverse program execution},
	file = {Agrawal, Demillo, Spafford 1993 - Debugging with dynamic slicing and backtracking.pdf:C\:\\Users\\c5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\p2iddxae.default\\zotero\\storage\\9BT38VTM\\Agrawal, Demillo, Spafford 1993 - Debugging with dynamic slicing and backtracking.pdf:application/pdf;Snapshot:C\:\\Users\\c5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\p2iddxae.default\\zotero\\storage\\4KSPWG25\\abstract.html:text/html}
}

@article{boehm_improving_1987,
	title = {Improving Software Productivity},
	abstract = {Computer hardware productivity continues to increase by leaps and bounds, while software productivity seems to be barely holding its own. Central processing units, random access memories, and mass memories improve their price-performance ratios by orders of magnitude per decade, while software projects continue to grind out production-engineered code at the same old rate of one to two delivered lines of code per man-hour. Yet, if software is judged by the same standards as hardware, its productivity looks pretty good. One can produce a million copies of Lotus 1-2-3 at least as cheaply as a million copies of the Intel 286. Database management systems that cost \$5 million 20 years ago can now be purchased for \$99.95. The commodity for which productivity has been slow to increase is custom software. Clearly, if you want to improve your organization’s software price-performance, one major principle is “Don’t build custom software where mass-produced software will satisfy your needs. ” However, even with custom software, a great deal is known about how to improve its productivity, and even},
	pages = {43--47},
	journaltitle = {Computer},
	author = {Boehm, Barry W.},
	date = {1987},
	file = {Boehm - 1987 - Improving Software Productivity.pdf:C\:\\Users\\c5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\p2iddxae.default\\zotero\\storage\\QXHWH67N\\Boehm - 1987 - Improving Software Productivity.pdf:application/pdf;Citeseer - Snapshot:C\:\\Users\\c5173086\\AppData\\Roaming\\Zotero\\Zotero\\Profiles\\p2iddxae.default\\zotero\\storage\\V39QE3SF\\summary.html:text/html}
}